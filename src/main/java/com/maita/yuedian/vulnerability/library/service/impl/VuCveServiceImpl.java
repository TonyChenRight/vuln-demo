package com.maita.yuedian.vulnerability.library.service.impl;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.io.IoUtil;
import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson2.JSON;
import com.alibaba.fastjson2.JSONArray;
import com.alibaba.fastjson2.JSONPath;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.maita.yuedian.vulnerability.library.domain.VuCnnvd;
import com.maita.yuedian.vulnerability.library.domain.VuCve;
import com.maita.yuedian.vulnerability.library.enums.LevelType;
import com.maita.yuedian.vulnerability.library.mapper.VuCveMapper;
import com.maita.yuedian.vulnerability.library.model.ImportResult;
import com.maita.yuedian.vulnerability.library.model.R;
import com.maita.yuedian.vulnerability.library.model.UserInfo;
import com.maita.yuedian.vulnerability.library.model.cve.*;
import com.maita.yuedian.vulnerability.library.service.VuCveService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.maita.yuedian.vulnerability.library.utils.FieldUtils;
import com.maita.yuedian.vulnerability.library.utils.FileTypeUtils;
import com.maita.yuedian.vulnerability.library.utils.RegexUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.nio.charset.StandardCharsets;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * <p>
 * CVE漏洞表 服务实现类
 * </p>
 *
 * @author jason
 * @since 2024-12-03
 */
@Service
public class VuCveServiceImpl extends ServiceImpl<VuCveMapper, VuCve> implements VuCveService {

    @Override
    public R<IPage<CvePage>> cvePage(CvePageParam param) {
        LambdaQueryWrapper<VuCve> queryWrapper = Wrappers.lambdaQuery(VuCve.class)
                .likeRight(StrUtil.isNotBlank(param.getName()), VuCve::getName, param.getName())
                .eq(StrUtil.isNotBlank(param.getCode()), VuCve::getCode, param.getCode())
                .eq(param.getId() != null, VuCve::getId, param.getId())
                .and(StrUtil.isNotBlank(param.getKeyword()),wrapper ->
                        wrapper.likeRight(VuCve::getCode, param.getKeyword())
                                .or()
                                .likeRight(VuCve::getName, param.getKeyword())
                )
                .orderByDesc(VuCve::getUpdatedTime);
        IPage<VuCve> listPage =super.page(new Page<>(param.getCurrent(), param.getSize()), queryWrapper);
        return R.ok(listPage.convert(CvePage::new));
    }

    @Transactional(rollbackFor = Exception.class)
    @Override
    public R<ImportResult> cveImport(MultipartFile file, UserInfo user) {
        if(!FileTypeUtils.isJson(file.getOriginalFilename())) {
            return R.error("文件格式不正确，必须是json文件");
        }
        List<CveFileEntry> entryList = parseJson(file);
        if (CollUtil.isEmpty(entryList)) {
            return R.error("文件解析失败");
        }
        Map<String, VuCve> codeToEntityMap = list().stream().collect(Collectors.toMap(VuCve::getCode, Function.identity(), (oldVal, newVal) -> oldVal));
        int totalCount = 0;
        int successCount = 0;
        int errorCount = 0;
        int repeatCount = 0;
        Map<String, String> errorDetails =new HashMap<>();
        List<VuCve> insertList = new ArrayList<>();
        Set<String> existsCodes = new HashSet<>();
        for (CveFileEntry fileEntry : entryList) {
            totalCount++;
            String code = fileEntry.getCode();
            if (StrUtil.isBlank(code)) {
                continue;
            }
            String errorMsg = checkField(fileEntry, existsCodes);
            if (StrUtil.isNotBlank(errorMsg)) {
                errorDetails.put(code, errorMsg);
                errorCount++;
                continue;
            }
            VuCve vuCve = codeToEntityMap.get(code);
            if (vuCve != null) {
                repeatCount++;
                continue;
            }
            successCount++;

            VuCve insertEntity = VuCve.buildForInsert(fileEntry, user);
            insertList.add(insertEntity);
        }

        if (CollUtil.isNotEmpty(insertList)) {
            saveBatch(insertList);
        }
        ImportResult result = ImportResult.builder()
                .totalCount(totalCount)
                .successCount(successCount)
                .errorCount(errorCount)
                .repeatCount(repeatCount)
                .errorDetails(errorDetails)
                .build();
        return R.ok(result);
    }

    private String checkField(CveFileEntry fileEntry, Set<String> existsCodes) {
        StringBuilder errorMsg = new StringBuilder();
        if (existsCodes.contains(fileEntry.getCode())) {
            errorMsg.append(String.format("标签[%s]数据重复！", "vuln-id"));
        }
        existsCodes.add(fileEntry.getCode());

        String published = fileEntry.getPublished();
        if (StrUtil.isNotBlank(published)) {
            try {
                fileEntry.setPublishTime(parseDateTime(published));
            }catch (Exception e){
                log.error("published time parse error:", e);
                errorMsg.append(String.format("标签[%s]内容格式不正确！", "published"));
            }
        }
        String modified = fileEntry.getModified();
        if (StrUtil.isNotBlank(modified)) {
            try {
                fileEntry.setModifyTime(parseDateTime(modified));
            }catch (Exception e){
                log.error("modified time parse error:", e);
                errorMsg.append(String.format("标签[%s]内容格式不正确！", "modified"));
            }
        }
        String severity = fileEntry.getBaseSeverity();
        if (StrUtil.isNotBlank(severity)) {
            LevelType levelType = LevelType.findByEnName(severity);
            if (levelType == null) {
                errorMsg.append(String.format("标签[%s]内容格式不正确！", "severity"));
            }else {
                fileEntry.setLevel(levelType.getValue());
            }
        }
        return errorMsg.toString();
    }

    private List<CveFileEntry> parseJson(MultipartFile file) {
        try {
            String json = IoUtil.read(file.getInputStream(), StandardCharsets.UTF_8);
            if (StrUtil.isBlank(json)) {
                return new ArrayList<>();
            }
            CveFileEntry cveFileEntry =new CveFileEntry();
            cveFileEntry.setCode(FieldUtils.safeGetString(JSONPath.eval(json, "$.cveMetadata.cveId")));
            cveFileEntry.setPublished(FieldUtils.safeGetString(JSONPath.eval(json, "$.cveMetadata.datePublished")));
            cveFileEntry.setModified(FieldUtils.safeGetString(JSONPath.eval(json, "$.cveMetadata.dateUpdated")));
            cveFileEntry.setState(FieldUtils.safeGetString(JSONPath.eval(json, "$.cveMetadata.state")));

            JSONArray affected = (JSONArray) JSONPath.eval(json, "$.containers.cna.affected");
            List<CveFileEntryAffect> entryAffects =new ArrayList<>();
            if (affected != null && !affected.isEmpty()) {
                for (int i = 0; i < affected.size(); i++) {
                    Object item = affected.get(i);
                    CveFileAffected fileAffected = JSON.parseObject(JSON.toJSONString(item), CveFileAffected.class);
                    CveFileEntryAffect entryAffect = new CveFileEntryAffect();
                    entryAffect.setProduct(fileAffected.getProduct());
                    List<String> platforms = fileAffected.getPlatforms();
                    if (CollUtil.isNotEmpty(platforms)) {
                        entryAffect.setPlatforms(platforms);
                    }
                    List<CveFileAffected.VersionDetail> versions = fileAffected.getVersions();
                    List<String> versionList =new ArrayList<>();
                    if (CollUtil.isNotEmpty(versions)) {
                        for (CveFileAffected.VersionDetail version : versions) {
                            StringBuilder sb =new StringBuilder();
                            String lessThan = version.getLessThan();
                            String lessThanOrEqual = version.getLessThanOrEqual();
                            sb.append(version.getVersion());
                            if (StrUtil.isNotBlank(lessThan)) {
                                sb.append("~").append(lessThan);
                            }else if(StrUtil.isNotBlank(lessThanOrEqual)) {
                                sb.append("~").append(lessThanOrEqual);
                            }
                            versionList.add(sb.toString());
                        }
                    }
                    entryAffect.setVersions(versionList);
                    entryAffects.add(entryAffect);
                }
            }
            cveFileEntry.setAffectRange(entryAffects);

            JSONArray metrics = (JSONArray) JSONPath.eval(json, "$.containers.cna.metrics");
            if (metrics != null && !metrics.isEmpty()) {
                List<CveFileMetrics> list = metrics.toList(CveFileMetrics.class);
                Optional<CveFileMetrics> maxed = list.stream().max(Comparator.comparing(CveFileMetrics::getVersion));
                if (maxed.isPresent()) {
                    Object item = maxed.get();
                    cveFileEntry.setBaseScore(FieldUtils.safeGetString(JSONPath.eval(item, "$.baseScore")));
                    cveFileEntry.setBaseSeverity(FieldUtils.safeGetString(JSONPath.eval(item, "$.baseSeverity")));
                }
            }

            JSONArray descriptions = (JSONArray) JSONPath.eval(json, "$.containers.cna.descriptions");
            List<String> remarkList =new ArrayList<>();
            if (descriptions != null && !descriptions.isEmpty()) {
                for (int i = 0; i < descriptions.size(); i++) {
                    Object item = descriptions.get(i);
                    remarkList.add(FieldUtils.safeGetString(JSONPath.eval(item, "$.value")));
                }
            }
            cveFileEntry.setRemark(remarkList);

            JSONArray references = (JSONArray) JSONPath.eval(json, "$.containers.cna.references");
            List<String> repairMethods=new ArrayList<>();
            if (references != null && !references.isEmpty()) {
                for (CveFileReferences fileReferences : references.toList(CveFileReferences.class)) {
                    repairMethods.add(fileReferences.getUrl());
                }
            }
            cveFileEntry.setRepairMethods(repairMethods);
            cveFileEntry.setName((String) JSONPath.eval(json, "$.containers.cna.title"));
            return List.of(cveFileEntry);
        }catch (Exception e) {
            log.error("parseJson error", e);
            return new ArrayList<>();
        }
    }

    private Long parseDateTime(String dateTimeText) {
        int idx = dateTimeText.indexOf(".");
        if (idx != -1) {
            dateTimeText = dateTimeText.substring(0, idx);
        }
        return DateUtil.parse(dateTimeText, DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss")).getTime();
    }
}
