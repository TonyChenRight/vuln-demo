package com.maita.yuedian.vulnerability.library.service.impl;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.date.DateTime;
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.crypto.digest.DigestUtil;
import com.alibaba.excel.EasyExcel;
import com.alibaba.excel.context.AnalysisContext;
import com.alibaba.excel.event.AnalysisEventListener;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.maita.yuedian.vulnerability.library.domain.VuCustom;
import com.maita.yuedian.vulnerability.library.domain.VuCve;
import com.maita.yuedian.vulnerability.library.enums.LevelType;
import com.maita.yuedian.vulnerability.library.mapper.VuCustomMapper;
import com.maita.yuedian.vulnerability.library.model.ImportResult;
import com.maita.yuedian.vulnerability.library.model.R;
import com.maita.yuedian.vulnerability.library.model.UserInfo;
import com.maita.yuedian.vulnerability.library.model.custom.CustomEditParam;
import com.maita.yuedian.vulnerability.library.model.custom.CustomImportPreview;
import com.maita.yuedian.vulnerability.library.model.custom.CustomPage;
import com.maita.yuedian.vulnerability.library.model.custom.CustomPageParam;
import com.maita.yuedian.vulnerability.library.model.cve.CveFileEntry;
import com.maita.yuedian.vulnerability.library.model.cve.CvePage;
import com.maita.yuedian.vulnerability.library.service.VuCustomService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.maita.yuedian.vulnerability.library.utils.FileTypeUtils;
import com.maita.yuedian.vulnerability.library.utils.RegexUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * <p>
 * 自定义表 服务实现类
 * </p>
 *
 * @author jason
 * @since 2024-12-03
 */
@Slf4j
@Service
public class VuCustomServiceImpl extends ServiceImpl<VuCustomMapper, VuCustom> implements VuCustomService {

    @Override
    public R<IPage<CustomPage>> customPage(CustomPageParam param) {
        LambdaQueryWrapper<VuCustom> queryWrapper = Wrappers.lambdaQuery(VuCustom.class)
                .likeRight(StrUtil.isNotBlank(param.getName()), VuCustom::getName, param.getName())
                .eq(StrUtil.isNotBlank(param.getCode()), VuCustom::getCode, param.getCode())
                .eq(param.getId() != null, VuCustom::getId, param.getId())
                .and(StrUtil.isNotBlank(param.getKeyword()),wrapper ->
                        wrapper.likeRight(VuCustom::getCode, param.getKeyword())
                                .or()
                                .likeRight(VuCustom::getName, param.getKeyword())
                )
                .orderByDesc(VuCustom::getUpdatedTime);
        IPage<VuCustom> listPage =super.page(new Page<>(param.getCurrent(), param.getSize()), queryWrapper);
        return R.ok(listPage.convert(CustomPage::new));
    }

    @Override
    public R<Long> customEdit(CustomEditParam param, UserInfo userInfo) {
        Long id = param.getId();
        VuCustom queryCustomByCode = getOne(Wrappers.lambdaQuery(VuCustom.class)
                .eq(VuCustom::getCode, param.getCode()));
        if(queryCustomByCode != null && !Objects.equals(queryCustomByCode.getId(), id)){
            return R.error("编码已存在");
        }

        if (id == null) {
            VuCustom custom = VuCustom.buildForInsert(param, userInfo);
            save(custom);
            return R.ok(custom.getId());
        }

        VuCustom oldCustom = getById(id);
        if (oldCustom == null) {
            return R.error("数据不存在");
        }

        VuCustom custom =VuCustom.buildForUpdate(oldCustom, param, userInfo);
        updateById(custom);
        return R.ok(custom.getId());
    }

    @Override
    public R<Long> customDelete(Long id) {
        VuCustom oldCustom = getById(id);
        if (oldCustom == null) {
            return R.error("数据不存在");
        }
        removeById(id);
        return R.ok(oldCustom.getId());
    }

    @Transactional(rollbackFor = Exception.class)
    @Override
    public R<ImportResult> customImport(MultipartFile file, UserInfo user) {
        if(!FileTypeUtils.isExcel(file.getOriginalFilename())) {
            return R.error("文件格式不正确，必须是xls或者xlsx文件");
        }
        List<CustomImportPreview> importPreviews = parseExcel(file);
        if (CollUtil.isEmpty(importPreviews)) {
            return R.error("文件解析失败");
        }

        Map<String, VuCustom> codeToEntityMap = list().stream()
                .collect(Collectors.toMap(VuCustom::getCode, Function.identity(), (oldVal, newVal) -> oldVal));

        int totalCount = 0;
        int successCount = 0;
        int errorCount = 0;
        Map<String, String> errorDetails =new HashMap<>();
        List<VuCustom> insertList = new ArrayList<>();
        List<VuCustom> updateList = new ArrayList<>();
        Set<String> existsCodes = new HashSet<>();
        for (CustomImportPreview importPreview : importPreviews) {
            totalCount++;
            String code = importPreview.getCode();
            if (StrUtil.isBlank(code)) {
               continue;
            }
            String errorMsg = checkField(importPreview, existsCodes);
            if (StrUtil.isNotBlank(errorMsg)) {
                errorDetails.put(code, errorMsg);
                errorCount++;
                continue;
            }
            successCount++;

            VuCustom vuCustom = codeToEntityMap.get(code);
            if (vuCustom != null) {
                VuCustom updateEntity = VuCustom.buildForUpdateImport(vuCustom, importPreview, user);
                updateList.add(updateEntity);
            }else {
                VuCustom insertEntity = VuCustom.buildForInsertImport(importPreview, user);
                insertList.add(insertEntity);
            }
        }

        if (CollUtil.isNotEmpty(insertList)) {
            saveBatch(insertList);
        }
        if (CollUtil.isNotEmpty(updateList)) {
            updateBatchById(updateList);
        }
        ImportResult result = ImportResult.builder()
                .totalCount(totalCount)
                .successCount(successCount)
                .errorCount(errorCount)
                .errorDetails(errorDetails)
                .build();
        return R.ok(result);
    }

    private String checkField(CustomImportPreview importPreview, Set<String> existsCodes) {
        StringBuilder errorMsg = new StringBuilder();
        Integer rowIndex = importPreview.getRowIndex();
        String code = importPreview.getCode();
        if (existsCodes.contains(code)) {
            errorMsg.append(String.format("第[%d]行漏洞编码重复！", rowIndex));
        }
        existsCodes.add(code);

        String name = importPreview.getName();
        if (StrUtil.isBlank(name)) {
            errorMsg.append(String.format("第[%d]行漏洞名称为空！", rowIndex));
        }
        String remark = importPreview.getRemark();
        if (StrUtil.isBlank(remark)) {
            errorMsg.append(String.format("第[%d]行漏洞描述为空！", rowIndex));
        }
        String levelText = importPreview.getLevelText();
        if (StrUtil.isBlank(levelText)) {
            errorMsg.append(String.format("第[%d]行漏洞级别为空！", rowIndex));
        }else {
            LevelType byCnName = LevelType.findByCnName(levelText);
            if (byCnName == null) {
                errorMsg.append(String.format("第[%d]行漏洞级别格式不正确！", rowIndex));
            }else {
                importPreview.setLevel(byCnName.getValue());
            }
        }
        String affectProduct = importPreview.getAffectProduct();
        if (StrUtil.isBlank(affectProduct)) {
            errorMsg.append(String.format("第[%d]行影响产品为空！", rowIndex));
        }
        String affectVersion = importPreview.getAffectVersion();
        if (StrUtil.isBlank(affectVersion)) {
            errorMsg.append(String.format("第[%d]行影响版本为空！", rowIndex));
        }

        String publishText = importPreview.getPublishText();
        if (StrUtil.isNotBlank(publishText)) {
            if(!RegexUtils.test(publishText, RegexUtils.datetime)) {
                errorMsg.append(String.format("第[%d]行发布时间格式不正确！", rowIndex));
            }else {
                importPreview.setPublishTime(DateUtil.parseDateTime(publishText).getTime());
            }
        }
//        String modifyText = importPreview.getModifyText();
//        if (StrUtil.isNotBlank(modifyText)) {
//            if(!RegexUtils.test(modifyText, RegexUtils.datetime)) {
//                errorMsg.append(String.format("第[%d]行更新时间格式不正确！", rowIndex));
//            }else {
//                importPreview.setModifyTime(DateUtil.parseDateTime(modifyText).getTime());
//            }
//        }
        return errorMsg.toString();
    }


    private List<CustomImportPreview> parseExcel(MultipartFile file) {
        try {
            MyExcelImportListener readListener = new MyExcelImportListener();
            EasyExcel.read(file.getInputStream(), CustomImportPreview.class, readListener)
                    .headRowNumber(1)
                    .ignoreEmptyRow(true)
                    .autoCloseStream(true)
                    .sheet(0).doRead();
            return readListener.result;
        }catch (Exception e){
            log.error("parseExcel error", e);
            return new ArrayList<>();
        }
    }

    static class MyExcelImportListener extends AnalysisEventListener<CustomImportPreview> {
        List<CustomImportPreview> result;

        public MyExcelImportListener() {
            result = new ArrayList<>();
        }

        @Override
        public void invoke(CustomImportPreview customImportPreview, AnalysisContext analysisContext) {
            customImportPreview.setRowIndex(analysisContext.readRowHolder().getRowIndex() + 1);
            result.add(customImportPreview);
        }

        @Override
        public void doAfterAllAnalysed(AnalysisContext analysisContext) {

        }
    }
}
