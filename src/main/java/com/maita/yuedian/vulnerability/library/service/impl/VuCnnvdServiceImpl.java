package com.maita.yuedian.vulnerability.library.service.impl;

import cn.hutool.core.collection.CollUtil;
import cn.hutool.core.date.DateUtil;
import cn.hutool.core.util.StrUtil;
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.core.metadata.IPage;
import com.baomidou.mybatisplus.core.toolkit.Wrappers;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.maita.yuedian.vulnerability.library.domain.VuCnnvd;
import com.maita.yuedian.vulnerability.library.domain.VuCustom;
import com.maita.yuedian.vulnerability.library.enums.LevelType;
import com.maita.yuedian.vulnerability.library.mapper.VuCnnvdMapper;
import com.maita.yuedian.vulnerability.library.model.ImportResult;
import com.maita.yuedian.vulnerability.library.model.R;
import com.maita.yuedian.vulnerability.library.model.UserInfo;
import com.maita.yuedian.vulnerability.library.model.cnnvd.*;
import com.maita.yuedian.vulnerability.library.service.VuCnnvdService;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.maita.yuedian.vulnerability.library.service.helper.XmlParseHelper;
import com.maita.yuedian.vulnerability.library.utils.FileTypeUtils;
import com.maita.yuedian.vulnerability.library.utils.RegexUtils;
import jakarta.annotation.Resource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * <p>
 * CNNVD漏洞表 服务实现类
 * </p>
 *
 * @author jason
 * @since 2024-12-03
 */
@Service
public class VuCnnvdServiceImpl extends ServiceImpl<VuCnnvdMapper, VuCnnvd> implements VuCnnvdService {

    @Resource
    private XmlParseHelper xmlParseHelper;


    @Override
    public R<IPage<CnnvdPage>> cnnvdPage(CnnvdPageParam param) {
        LambdaQueryWrapper<VuCnnvd> queryWrapper = Wrappers.lambdaQuery(VuCnnvd.class)
                .likeRight(StrUtil.isNotBlank(param.getName()), VuCnnvd::getName, param.getName())
                .eq(StrUtil.isNotBlank(param.getCode()), VuCnnvd::getCode, param.getCode())
                .eq(param.getId() != null, VuCnnvd::getId, param.getId())
                .and(StrUtil.isNotBlank(param.getKeyword()),wrapper ->
                        wrapper.likeRight(VuCnnvd::getCode, param.getKeyword())
                        .or()
                        .likeRight(VuCnnvd::getName, param.getKeyword())
                )
                .orderByDesc(VuCnnvd::getUpdatedTime);
        IPage<VuCnnvd> listPage =super.page(new Page<>(param.getCurrent(), param.getSize()), queryWrapper);
        return R.ok(listPage.convert(CnnvdPage::new));
    }

    @Transactional(rollbackFor = Exception.class)
    @Override
    public R<ImportResult> cnnvdImport(MultipartFile file, UserInfo user) {
        if(!FileTypeUtils.isXml(file.getOriginalFilename())) {
            return R.error("文件格式不正确，必须是xml文件");
        }

        R<List<CnnvdFileEntry>> parseResult = xmlParseHelper.parseCnnvdEntryList(file);
        if (!parseResult.isSuccess()) {
            return R.error(parseResult.getMessage());
        }
        List<CnnvdFileEntry> entryList = parseResult.getData();
        Map<String, VuCnnvd> codeToEntityMap = list().stream().collect(Collectors.toMap(VuCnnvd::getCode, Function.identity(), (oldVal, newVal) -> oldVal));
        int totalCount = 0;
        int successCount = 0;
        int errorCount = 0;
        int repeatCount = 0;
        Map<String, String> errorDetails =new HashMap<>();
        List<VuCnnvd> insertList = new ArrayList<>();
        Set<String> existsCodes = new HashSet<>();
        for (CnnvdFileEntry fileEntry : entryList) {
            totalCount++;
            String code = fileEntry.getCode();
            if (StrUtil.isBlank(code)) {
                continue;
            }
            String errorMsg = checkField(fileEntry, existsCodes);
            if (StrUtil.isNotBlank(errorMsg)) {
                errorDetails.put(code, errorMsg);
                errorCount++;
                continue;
            }
            VuCnnvd vuCnnvd = codeToEntityMap.get(code);
            if (vuCnnvd != null) {
                repeatCount++;
                continue;
            }
            successCount++;

            VuCnnvd insertEntity = VuCnnvd.buildForInsert(fileEntry, user);
            insertList.add(insertEntity);
        }

        if (CollUtil.isNotEmpty(insertList)) {
            saveBatch(insertList);
        }
        ImportResult result = ImportResult.builder()
                .totalCount(totalCount)
                .successCount(successCount)
                .errorCount(errorCount)
                .repeatCount(repeatCount)
                .errorDetails(errorDetails)
                .build();
        return R.ok(result);
    }

    @Override
    public R<Long> cnnvdEdit(CnnvdEditParam param, UserInfo user) {
        Long id = param.getId();
        VuCnnvd oldCnnvd = getById(id);
        if (oldCnnvd == null) {
            return R.error("数据不存在");
        }

        VuCnnvd vuCnnvd = VuCnnvd.buildForManualUpdate(oldCnnvd, param, user);
        updateById(vuCnnvd);
        return R.ok(vuCnnvd.getId());
    }

    private String checkField(CnnvdFileEntry fileEntry, Set<String> existsCodes) {
        StringBuilder errorMsg = new StringBuilder();

        if (existsCodes.contains(fileEntry.getCode())) {
            errorMsg.append(String.format("标签[%s]数据重复！", "vuln-id"));
        }
        existsCodes.add(fileEntry.getCode());

        String published = fileEntry.getPublished();
        if (StrUtil.isNotBlank(published)) {
            if (!RegexUtils.test(published, RegexUtils.date)) {
                errorMsg.append(String.format("标签[%s]内容格式不正确！", "published"));
            }else {
                fileEntry.setPublishTime(DateUtil.parseDate(published).getTime());
            }
        }
        String modified = fileEntry.getModified();
        if (StrUtil.isNotBlank(modified)) {
            if (!RegexUtils.test(modified, RegexUtils.date)) {
                errorMsg.append(String.format("标签[%s]内容格式不正确！", "modified"));
            }else {
                fileEntry.setModifyTime(DateUtil.parseDate(modified).getTime());
            }
        }

        String severity = fileEntry.getSeverity();
        if (StrUtil.isNotBlank(severity)) {
            LevelType levelType = LevelType.findByCnName(severity);
            if (levelType == null) {
                errorMsg.append(String.format("标签[%s]内容格式不正确！", "severity"));
            }else {
                fileEntry.setLevel(levelType.getValue());
            }
        }
        return errorMsg.toString();
    }
}
